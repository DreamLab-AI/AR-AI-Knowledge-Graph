test_files_content = {
    "tests/server/graphController.test.js": '''const graphController = require('../../src/controllers/graphController');
const graphService = require('../../src/services/graphService');

jest.mock('../../src/services/graphService');

describe('GraphController', () => {
    test('should fetch and return graph data', async () => {
        const mockGraphData = { nodes: [], edges: [] };
        graphService.getGraphData.mockResolvedValue(mockGraphData);

        const req = {};
        const res = { json: jest.fn() };
        await graphController.getGraphData(req, res);

        expect(graphService.getGraphData).toHaveBeenCalled();
        expect(res.json).toHaveBeenCalledWith(mockGraphData);
    });

    test('should refresh graph data successfully', async () => {
        graphService.refreshGraphData.mockResolvedValue(true);

        const req = {};
        const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
        await graphController.refreshGraphData(req, res);

        expect(graphService.refreshGraphData).toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(200);
        expect(res.json).toHaveBeenCalledWith({ success: true });
    });
});
''',

    "tests/server/fileController.test.js": '''const fileController = require('../../src/controllers/fileController');
const fileService = require('../../src/services/fileService');

jest.mock('../../src/services/fileService');

describe('FileController', () => {
    test('should fetch file metadata from GitHub', async () => {
        const mockMetadata = [{ fileName: 'test.md', updated: true }];
        fileService.fetchMarkdownMetadata.mockResolvedValue(mockMetadata);

        const req = {};
        const res = { json: jest.fn() };
        await fileController.getFileMetadata(req, res);

        expect(fileService.fetchMarkdownMetadata).toHaveBeenCalled();
        expect(res.json).toHaveBeenCalledWith(mockMetadata);
    });

    test('should send file to OpenWebUI for processing', async () => {
        const mockProcessedFile = { content: 'Processed content', metadata: {} };
        fileService.processFileWithOpenWebUI.mockResolvedValue(mockProcessedFile);

        const req = { body: { fileName: 'test.md' } };
        const res = { json: jest.fn() };
        await fileController.processFile(req, res);

        expect(fileService.processFileWithOpenWebUI).toHaveBeenCalledWith('test.md');
        expect(res.json).toHaveBeenCalledWith(mockProcessedFile);
    });
});
''',

    "tests/server/ragflowController.test.js": '''const ragflowController = require('../../src/controllers/ragflowController');
const ragflowService = require('../../src/services/ragflowService');

jest.mock('../../src/services/ragflowService');

describe('RAGFlowController', () => {
    test('should send message to RAGFlow API and return response', async () => {
        const mockResponse = { response: 'Answer from RAGFlow' };
        ragflowService.sendMessage.mockResolvedValue(mockResponse);

        const req = { body: { conversationId: '123', message: 'What is this?' } };
        const res = { json: jest.fn() };
        await ragflowController.sendMessage(req, res);

        expect(ragflowService.sendMessage).toHaveBeenCalledWith('123', 'What is this?');
        expect(res.json).toHaveBeenCalledWith(mockResponse);
    });
});
''',

    "tests/server/fileService.test.js": '''const fileService = require('../../src/services/fileService');
const openWebUiService = require('../../src/services/openWebUiService');

jest.mock('../../src/services/openWebUiService');

describe('FileService', () => {
    test('should fetch Markdown file metadata from GitHub', async () => {
        const mockMetadata = [{ fileName: 'test.md', updated: true }];
        // Assuming some mocked function for GitHub API call
        fileService.fetchMarkdownMetadata = jest.fn().mockResolvedValue(mockMetadata);

        const metadata = await fileService.fetchMarkdownMetadata();
        expect(metadata).toEqual(mockMetadata);
    });

    test('should process file via OpenWebUI and return processed content', async () => {
        const mockFile = 'Raw content';
        const mockProcessed = { content: 'Processed content', metadata: {} };
        openWebUiService.processFile.mockResolvedValue(mockProcessed);

        const processedFile = await fileService.processFileWithOpenWebUI(mockFile);
        expect(openWebUiService.processFile).toHaveBeenCalledWith(mockFile);
        expect(processedFile).toEqual(mockProcessed);
    });
});
''',

    "tests/client/interface.test.js": '''import { Interface } from '../../src/components/interface';

describe('Interface', () => {
    let interfaceInstance;
    beforeEach(() => {
        const mockCamera = {};
        const mockScene = {};
        const mockNodes = [];
        interfaceInstance = new Interface(mockCamera, mockScene, mockNodes);
    });

    test('should initialize SpaceMouse input', () => {
        const spy = jest.spyOn(interfaceInstance, 'initSpaceMouse');
        interfaceInstance.initSpaceMouse();
        expect(spy).toHaveBeenCalled();
    });

    test('should handle SpaceMouse input', () => {
        const mockEvent = { someEventProperty: 'test' };
        const spy = jest.spyOn(interfaceInstance, 'handleSpaceMouseInput');
        interfaceInstance.handleSpaceMouseInput(mockEvent);
        expect(spy).toHaveBeenCalledWith(mockEvent);
    });
});
''',

    "tests/client/websocketService.test.js": '''import { WebSocketService } from '../../src/services/websocketService';

describe('WebSocketService', () => {
    let websocketService;

    beforeEach(() => {
        websocketService = new WebSocketService();
        global.WebSocket = jest.fn(() => ({
            send: jest.fn(),
            addEventListener: jest.fn(),
            close: jest.fn()
        }));
    });

    test('should send WebSocket message correctly', () => {
        websocketService.connect();
        websocketService.sendMessage({ type: 'test' });
        expect(WebSocket.mock.instances[0].send).toHaveBeenCalledWith(JSON.stringify({ type: 'test' }));
    });

    test('should handle WebSocket message events', () => {
        const mockEvent = { data: JSON.stringify({ type: 'nodePositions', positions: [] }) };
        const onMessageSpy = jest.spyOn(websocketService, 'handleMessage');
        websocketService.handleMessage(mockEvent);
        expect(onMessageSpy).toHaveBeenCalledWith(mockEvent);
    });
});
